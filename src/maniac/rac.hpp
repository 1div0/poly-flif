#pragma once

#ifdef STATS
#include <stdio.h>
#endif

#include <stdint.h>
#include <assert.h>
#include "../config.h"

/* RAC configuration for 24-bit RAC */
class RacConfig24
{
public:
    typedef uint32_t data_t;
    static const data_t MAX_RANGE_BITS = 24;
    static const data_t MIN_RANGE_BITS = 16;
    static const data_t MIN_RANGE = (1UL << MIN_RANGE_BITS);
    static const data_t BASE_RANGE = (1UL << MAX_RANGE_BITS);

    static inline data_t chance_12bit_chance(int b12, data_t range) {
        assert(b12 > 0);
        assert((b12 >> 12) == 0);
        // We want to compute (range * b12 + 0x800) >> 12.
        // Unfortunately, this can overflow the 32-bit data type, so split range
        // in its lower and upper 12 bits, and compute separately.
        return ((((range & 0xFFF) * b12 + 0x800) >> 12) + ((range >> 12) * b12));
    }
};

template <typename Config, typename IO> class RacInput
{
public:
    typedef typename Config::data_t rac_t;
protected:
    IO& io;
private:
#ifdef STATS
    uint64_t samples;
#endif
    rac_t range;
    rac_t low;
private:
    int read_catch_eof() {
        int c = io.getc();
        if(c == io.EOS) return 0;
        return c;
    }
    void inline input() {
        while (range <= Config::MIN_RANGE) {
            low <<= 8;
            range <<= 8;
            low |= read_catch_eof();
        }
    }
    bool inline get(rac_t chance) {
#ifdef STATS
        samples++;
#endif
        assert(chance > 0);
        assert(chance < range);
        if (low >= range - chance) {
            low -= range - chance;
            range = chance;
            input();
            return 1;
        } else {
            range -= chance;
            input();
            return 0;
        }
    }
public:
    RacInput(IO& ioin) : io(ioin), range(Config::BASE_RANGE), low(0) {
#ifdef STATS
        samples = 0;
#endif
        rac_t r = Config::BASE_RANGE;
        while (r > 1) {
            low <<= 8;
            low |= read_catch_eof();
            r >>= 8;
        }
    }

#ifdef STATS
    ~RacInput() {
        fprintf(stderr, "Total samples read from range coder: %llu\n", (unsigned long long)samples);
    }
#endif

    bool inline read_12bit_chance(int b12) {
        return get(Config::chance_12bit_chance(b12, range));
    }

    bool inline read_bit() {
        return get(range >> 1);
    }
};

#ifdef HAS_ENCODER
template <class Config, typename IO> class RacOutput
{
public:
    typedef typename Config::data_t rac_t;
protected:
    IO& io;
private:
    rac_t range;
    rac_t low;
    int delayed_byte;
    int delayed_count;

    void inline output() {
        while (range <= Config::MIN_RANGE) {
            int byte = low >> Config::MIN_RANGE_BITS;
            if (delayed_byte < 0) { // first generated byte
                delayed_byte = byte;
            } else if (((low + range) >> 8) < Config::MIN_RANGE) { // definitely no overflow
                io.fputc(delayed_byte);
                while (delayed_count) {
                    io.fputc(0xFF);
                    delayed_count--;
                }
                delayed_byte = byte;
            } else if ((low >> 8) >= Config::MIN_RANGE) { // definitely overflow
                io.fputc(delayed_byte + 1);
                while (delayed_count) {
                    io.fputc(0);
                    delayed_count--;
                }
                delayed_byte = byte & 0xFF;
            } else {
                delayed_count++;
            }
            low = (low & (Config::MIN_RANGE - 1)) << 8;
            range <<= 8;
        }
    }
    void inline put(rac_t chance, bool bit) {
        assert(chance > 0);
        assert(chance < range);
        if (bit) {
            low += range - chance;
            range = chance;
        } else {
            range -= chance;
        }
        output();
    }
public:
    RacOutput(IO& ioin) : io(ioin), range(Config::BASE_RANGE), low(0), delayed_byte(-1), delayed_count(0) { }

    void inline write_12bit_chance(uint16_t b12, bool bit) {
        put(Config::chance_12bit_chance(b12, range), bit);
    }

    void inline write_bit(bool bit) {
        put(range >> 1, bit);
    }

    void inline flush() {
        low += (Config::MIN_RANGE - 1);
        range = Config::MIN_RANGE - 1;
        output();
        range = Config::MIN_RANGE - 1;
        output();
        range = Config::MIN_RANGE - 1;
        output();
        io.flush();
    }
};
#endif


class RacDummy
{
public:
    void inline write_12bit_chance(uint16_t b12, bool) { }
    void inline write_bit(bool) { }
    void inline flush() { }
};


template <typename IO> class RacInput24 : public RacInput<RacConfig24, IO>
{
public:
    RacInput24(IO& io) : RacInput<RacConfig24, IO>(io) { }
};

#ifdef HAS_ENCODER
template <typename IO> class RacOutput24 : public RacOutput<RacConfig24, IO>
{
public:
    RacOutput24(IO& io) : RacOutput<RacConfig24, IO>(io) { }
};

#endif
